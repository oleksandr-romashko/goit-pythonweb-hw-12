# üß™ AUTH TEST PLAN ‚Äî FastAPI Contacts App

**Goal:** Manual verification of authentication and authorization functionality.  
**Scope:** `api/auth/*` routes, JWT tokens, and authorization dependencies.  
**Version:** 1 for Stage 2 ‚Äî Authentication & Authorization  
**Date:** 2025-12-07  
**Tester:** Oleksandr Romashko
**Testing Environment:** OS: Ubuntu 24.04.3 LTS, Browser: Firefox Browser 145.0.2 (64-bit)

---

## ‚úÖ CHECKLIST OVERVIEW
- [x] User registration
- [x] Email Verification
- [x] Resend Verification Email
- [x] User login
- [x] OAuth2 login
- [x] JWT token validation
- [x] Token payload verification
- [x] Role-based access control
- [x] End-to-end integration

---

## üîπ 1. User Registration (`POST /auth/register`)

**Goal:** Verify new user creation and validation logic.

| #     | Description                               | Input                                                                           | Expected Result                                            | Status |
| ----- | ----------------------------------------- | ------------------------------------------------------------------------------- | ---------------------------------------------------------- | ------ |
| 1 | Register a valid user                     | `{ "username": "john", "email": "john@mail.com", "password": "StrongPass123" }` | ‚úÖ 201 Created, user stored, `Location: /api/users/me`      | ‚úÖ Passed      |
| 2 | Register same user twice                  | same as (1)                                                                     | ‚ùå 409 Conflict `"Username is already taken"`                       | ‚úÖ Passed      |
| 3 | Reserved username (`admin`, `root`, etc.) | depends on `app_config.RESERVED_USERNAMES`                                      | ‚ùå 409 Conflict `"This username is reserved and cannot be used"`                                             | ‚úÖ Passed       |
| 4 | Username case sensitivity conflict                     | Username "john" vs "John" (case normalization) | ‚ùå 409 Conflict `"Username is already taken"`      | ‚úÖ Passed      |
| 5 | Invalid email                             | `"email": "not-email"`                                                          | ‚ùå 422 Validation Error                                     | ‚úÖ Passed      |
| 6 | Email case sensitivity conflict                     | Email "john@mail.com" vs "John@mail.com" (case normalization) | ‚ùå 409 Conflict `"User with such Email is already registered"`      | ‚úÖ Passed      |
| 7 | Weak password                             | `"password": "123"`                                                             | ‚ùå 422 Validation Error | ‚úÖ Passed      |

---

## üîπ 2.1 Email Verification - Email Delivery (MAIL CHECK)

**Goal:** Ensure that the verification email is delivered, contains the correct text, formatting, and a valid verification link.

| #     | Description                                  | Input                 | Expected Result                                                                      | Status |
| ----- | -------------------------------------------- | --------------------- | ------------------------------------------------------------------------------------ | ------ |
| 1 | Email is delivered after registration        | newly registered (non-superadmin) user | ‚úÖ Email arrives in inbox within 1 minute                                             | ‚úÖ Passed*      |
| 2 | Email is not delivered for superadmin user at superadmin seeding stage        | newly registered superadmin user | ‚úÖ Email arrives in inbox within 1 minute                                             | ‚úÖ Passed      |
| 3 | Email subject is correct                     | ‚Äî                     | ‚úÖ Subject: "Verify your email" (or the exact subject used by the app)                | ‚úÖ Passed      |
| 4 | Email body formatting                        | ‚Äî                     | ‚úÖ Contains greeting, instructions, no broken HTML or template placeholders           | ‚úÖ Passed      |
| 5 | Email includes verification link             | ‚Äî                     | ‚úÖ Contains clickable link with token as query parameter                              | ‚úÖ Passed      |
| 6 | Verification link points to correct endpoint | open link             | ‚úÖ Correct route: `/auth/verify-email?token=XYZ`                                      | ‚úÖ Passed      |
| 7 | Link token matches the one generated by app  | compare logs/db       | ‚úÖ Token is identical to stored verification token                                    | ‚úÖ Passed      |
| 8 | Link opens without errors, no redirect                    | click link            | ‚úÖ Returns correct JSON if no redirect link in the environment variables | ‚úÖ Passed      |
| 9 | Link opens without errors, redirect                    | click link            | ‚úÖ 302 Found. Returns correct redirect page, if redirect link is provided as an environmental variable | ‚ö†Ô∏è Passed*      |


## üîπ 2.2 Email Verification - Invalid & Expired Tokens

**Goal:** Ensure the system correctly rejects invalid or expired verification tokens.

| #     | Description                 | Input                | Expected Result                            | Status |
| ----- | --------------------------- | -------------------- | ------------------------------------------ | ------ |
| 1 | Invalid token format        | token="abc123"       | ‚ùå 400 Bad Request    | ‚úÖ Passed      |
| 2 | Token for non-existing user | token for deleted ID | ‚ùå 400 Bad Request                           | ‚úÖ Passed      |
| 3 | Expired token               | artificially expired | ‚ùå 400 Bad Request | ‚úÖ Passed      |
| 4 | Token already used          | same token twice     | ‚ùå 400 Bad Reuest with message "Your email is already verified."        | ‚úÖ Passed      |

## üîπ 2.3 Resend Verification Email (`POST /auth/resend-verification-email`)

**Goal:** Ensure that users can request a new verification email and that security constraints are met.

| #     | Description                                 | Input                        | Expected Result                               | Status |
| ----- | ------------------------------------------- | ---------------------------- | --------------------------------------------- | ------ |
| 1 | Resend for existing unverified user         | `{ "email": "john@mail.com" }` | ‚úÖ 200 OK, message: `"Please check your email for the confirmation letter"` | ‚úÖ Passed      |
| 2 | Resend for already verified user            | verified user's email        | ‚ùå 400 `"Your email is already verified."`         | ‚úÖ Passed      |
| 3 | Resend for non-existing email (security OK) | random email like a@b.c      | ‚úÖ 200 OK, same neutral message               | ‚úÖ Passed      |
| 4 | Resend sends a **new** token                | compare old + new tokens     | ‚úÖ tokens differ                              | ‚úÖ Passed*      |
| 5 | Email is actually sent                      | check inbox                  | ‚úÖ email received                             | ‚úÖ Passed      |

---

## üîπ 3. Email Verification (`GET /auth/verify-email?token=XYZ`)

**Goal:** Ensure that the user can successfully verify their email using the verification token sent during registration, and that invalid or reused tokens do not work.

| #     | Description               | Input                         | Expected Result                                            | Status |
| ----- | ------------------------- | ----------------------------- | ---------------------------------------------------------  | ------ |
| 1 | Valid verification token  | correct token                 | ‚úÖ 200 OK, email marked as verified, user.is_verified=True | ‚úÖ Passed      |
| 2 | Invalid token (malformed) | token="abc123"                | ‚ùå 400 `"Invalid or expired mail token"`                    | ‚úÖ Passed      |
| 3 | Expired token             | expired verification token    | ‚ùå 400 `"Invalid or expired mail token"`                                   | ‚úÖ Passed      |
| 4 | Already verified user     | valid token but user verified | ‚ùå 400 `"Your email is already verified."`  | ‚úÖ Passed      |
| 5 | Missing token             | no `token` in query params    | ‚ùå 422 Unprocessable Entity `"Field required"`                                         | ‚úÖ Passed      |
| 6 | Empty token             | `token` in query params is empty    | ‚ùå 400 `"Invalid or expired mail token"`                                         | ‚úÖ Passed      |
| 7 | Non-existing or deleted user | valid token but user not found | ‚ùå 400 `"Invalid or expired mail token"`                            | ‚úÖ Passed      |
| 8 | Redirect after email verification (if EMAIL_VERIFICATION_REDIRECT_URL in `.env`) | token valid | ‚úÖ 302 Redirect to configured URL | ‚úÖ Passed |

---

## üîπ 4. User Login (`POST /auth/login`)

**Goal:** Verify login and token issuance. Ensure unverified users cannot log in (if your implementation enforces this).

| #     | Description       | Input                   | Expected Result                                  | Status |
| ----- | ----------------- | ----------------------- | ------------------------------------------------ | ------ |
| 1 | Login attempt before verifying email | valid username/password | ‚ùå 401 Unauthorized `"Email verification is required"` | ‚úÖ Passed      |
| 2 | Valid credentials | valid username/password | ‚úÖ 200 OK, returns both access and refresh tokens | ‚úÖ Passed      |
| 3 | Username case sensitivity | "John" vs "john" (case normalization) | ‚úÖ 200 OK, returns both access and refresh tokens | ‚úÖ Passed |
| 4 | Login immediately after email verification (without delay) | username/password | ‚úÖ 200 OK      | ‚úÖ Passed |
| 5 | Invalid password  | wrong password          | ‚ùå 401 Unauthorized `"Invalid username or password"`                               | ‚úÖ Passed      |
| 6 | Non-existent user | username not in DB      | ‚ùå 401 Unauthorized `"Invalid username or password"`                               | ‚úÖ Passed      |
| 7 | Empty body        | `{}`                    | ‚ùå 422 Unprocessable Entity with info about required fields `"Field required"`                           | ‚úÖ Passed      |
| 8 | Not active user | user is not active      | ‚úÖ 200 OK, returns both access and refresh tokens                               | ‚úÖ Passed      |

---

## üîπ 5. OAuth2 Login (`POST /auth/oauth2-login`)

**Format:** `x-www-form-urlencoded` (fields: `username`, `password`)

| #     | Description                  | Expected Result           | Status |
| ----- | ---------------------------- | ------------------------- | ------ |
| 1 | Valid credentials            | ‚úÖ 200 OK, returns both access and refresh tokens | ‚úÖ Passed      |
| 2 | Valid credentials - authorization in swagger docs (`/docs`) using Authorize button and auth form             | ‚úÖ 200 OK, stays logged in and send authorized requests during docs session | ‚úÖ Passed      |
| 2 | Invalid password             | ‚ùå 401 Unauthorized `"Invalid username or password"`       | ‚úÖ Passed      |
| 3 | Login before verifying email (unverified user) | ‚ùå 401 Unauthorized `"Email verification is required"` | ‚úÖ Passed |

---

## üîπ 6. JWT Access Token ‚Äî Validation

**Goal:** Verify token generation and validation logic.

| #     | Description    | Action                      | Expected Result               | Status |
| ----- | -------------- | --------------------------- | ----------------------------- | ------ |
| 1 | Valid token    | Call `/users/me` with token | ‚úÖ 200 OK                      | ‚úÖ Passed      |
| 2 | Expired token  | Modify `exp` to the past    | ‚ùå 400 Bad Reuest `"Invalid or expired access token"` when accessing `GET /api/users/me/` | ‚úÖ Passed      |
| 3 | Tampered token | Change one character        | ‚ùå 401 Unauthorized `"Invalid or expired access token"` | ‚úÖ Passed      |
| 4 | Missing token  | No `Authorization` header   | ‚ùå 401 Unauthorized `"Not authenticated"`            | ‚úÖ Passed      |

---

## üîπ 7. JWT Refresh Token ‚Äî Validation

**Goal:** Verify `/auth/refresh` endpoint and its behavior across valid, expired, tampered, or invalid user states.

| #      | Scenario                                     | Action / Input                                     | Expected Result                                                       | Status |
| ------ | -------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------- | ------ |
| 1  | Valid refresh token from active user         | Send `POST /auth/refresh` with valid refresh token | ‚úÖ 200 OK, returns new access token (new `exp`, new `jti`)             | ‚úÖ Passed      |
| 2  | Tampered refresh token                       | Manually alter one character                       | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"`                                        | ‚úÖ Passed      |
| 3  | Wrong token type (access instead of refresh) | Send `access_token` as `refresh_token`             | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"`                                        | ‚úÖ Passed      |
| 4  | Expired refresh token                        | Use token with expired `exp`                       | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"`                                        | ‚úÖ Passed      |
| 5  | Refresh for deleted user                     | Delete user from DB, then call `/auth/refresh`     | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"` | ‚úÖ Passed      |
| 6  | Refresh for inactive user                    | Set `user.is_active=False`, then `/auth/refresh`   | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"`            | ‚úÖ Passed      |
| 7  | Refresh token with non-numeric `sub`         | Forge payload `sub="abc"`                          | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"` (due to `enforce_numeric_sub=True` claim must be numeric, debug logged)    | ‚úÖ Passed      |
| 8  | Refresh token missing `jti`                  | Remove `jti` from payload                          | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"`                                        | ‚úÖ Passed      |
| 9  | Reuse refresh token multiple times           | Use same refresh token twice                       | ‚úÖ 200 OK both (any) times (refresh not invalidated)                         | ‚úÖ Passed      |
| 10  | Missing `aud` claim in payload           | Provide jwt without `aud`                       | ‚ùå 401 Unauthorized `"Invalid or expired refresh token"                         | ‚úÖ Passed      |


**Additional cases to consider:**

* `ISS` claim check (implemented, not used).


üìò **Notes:**
> - Refresh tokens **are reusable** (not invalidated upon use).  
> - Inactive or deleted users always return `401` without revealing which case occurred.  
> - Changing `AUTH_JWT_SECRET` immediately invalidates all existing tokens.

---

## üîπ 8. Token Payload Verification

**Goal:** Validate contents of issued JWTs.

### Steps:
1. Obtain token via `/auth/login`.
2. Decode using [jwt.io](https://jwt.io/).
3. Confirm:
   - `sub` = `user.id`
   - `aud` = `"access_token"`
   - `exp` ‚âà `iat + AUTH_JWT_ACCESS_EXPIRATION_SECONDS`
   - Fields `jti`, `iat`, `exp` are present.
   - Custom claim `token_type` is present
   - Token contains all expected claims

** Results:**

1. Token `/auth/login`: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzX3Rva2VuIiwic3ViIjoiNCIsImF1ZCI6ImFwaSIsImp0aSI6IjBhMTNiMDVjLTJmYzMtNDE0ZS05MWRiLTUxZDA4NGI4YjM5MCIsImlhdCI6MTc2NTE1MjgyMiwiZXhwIjoxNzY1MTU2NDIyfQ.NpUbj2Nl8oc3T9ymHP7v3h8O2rRr3BujWTBfEkNSfqQ
2. Decoded token
   ```
   {
      "token_type": "access_token",
      "sub": "4",
      "aud": "api",
      "jti": "0a13b05c-2fc3-414e-91db-51d084b8b390",
      "iat": 1765152822,
      "exp": 1765156422
   }
   ```
3. Confirm:
   - `sub` = `user.id`  ‚úÖ  Passed
   - `aud` = `"access_token"`  ‚úÖ  Passed
   - `exp` ‚âà `iat + AUTH_JWT_EXPIRATION_SECONDS`  ‚úÖ  Passed
   - Fields `jti`, `iat`, `exp` are present.  ‚úÖ  Passed
   - Custom claim `token_type` is present  ‚úÖ  Passed
   - Token contains all expected claims ‚úÖ Passed

---

## üîπ 9. Role-Based Access Control

**Goal:** Verify role enforcement for dependency guards:  
`get_current_active_user`, `get_current_active_admin_user`, `get_current_superadmin_user`.

| #     | Scenario                              | User Role              | Expected Result | Status |
| ----- | ------------------------------------- | ---------------------- | --------------- | ------ |
| 1 | Active user ‚Üí `/users/me`             | USER                   | ‚úÖ 200        | ‚úÖ Passed      |
| 2 | Deactivated user ‚Üí `/users/me`                      | USER (is_active=False) | ‚ùå 403 Forbidden `"Inactive user"` | ‚úÖ Passed      |
| 3 | USER accessing admin route            | USER                   | ‚ùå 403 Forbidden `"Access denied"` | ‚úÖ Passed      |
| 4 | ADMIN accessing admin route           | ADMIN                  | ‚úÖ 200 OK        | ‚úÖ Passed      |
| 5 | ADMIN accessing superadmin route      | ADMIN                  | ‚ùå 403 Forbidden | ‚úÖ Passed      |
| 6 | SUPERADMIN accessing superadmin route | SUPERADMIN             | ‚úÖ 200 OK        | ‚úÖ Passed      |

---

## üîπ 10. End-to-End Flow

**Scenario "happy path":**  ‚úÖ Passed

1. Register a new user.
2. Confirm email address.
3. Login and obtain JWT tokens.  
4. Call `/users/me` with `access_token`.  
5. Receive user info (no 401/403 errors).

---

üìã **Notes & Observations**
> Use this section for any findings, anomalies, or improvement suggestions:
>
> - ...
> - ...

2.1.1 Disposable email service https://temp-mail.org/ used for this and other email tests.
2.1.9 Full-featured email URL like https://example.com/ should be used, otherwise no redirect will occur with something like this example.com. Tested in Firefox, so other browsers may have different approach of handling this. Maybe to check all necessary URL attributed before redirecting, to make it more robust?
2.2.2 Should I ‚ùå 404 Not Found for confirmation link for non-existing user.
2.3.4 Tokens itself differs. Each token has it's own jti claim (token id) at creation too. No way of storing issued tokens is implemented yet.