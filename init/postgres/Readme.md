# How the Database Init Works

This directory contains initialization logic for the PostgreSQL container in our Docker Compose setup.

## üß† Why this exists

We want to:

* **Keep our database secure**, by **not using the** `postgres` **superuser** for our backend app.
* Automatically create a **limited-privilege database user** (`app_user`) on first-time startup of the container.

Allow reusability and configurability by using values from the `.env` file.

## ‚öôÔ∏è How it works (step-by-step)

1. **‚úÖ Compose reads the .env file**

    Docker Compose loads environment variables defined in `.env` file. This includes credentials like:
    ```
    # Name of the database your app will use
    DB_NAME=contacts_app

    # App-level PostgreSQL user and password
    DB_APP_USER=app_user
    DB_APP_USER_PASSWORD=your_db_app_user_password_here

    ```

2. **üóëÔ∏è We mount a shell script into the init folder**

    In `docker-compose.yml`:

    ```yaml
    services:
    db:
        volumes:
        - ./db/init.sh:/docker-entrypoint-initdb.d/init.template.sql
    ```
    
    * `init.template.sql` is marked executable (`chmod +x`).
    * It uses `envsubst` to substitute environment variables into `init.sql`.
    * It generates a final SQL script `init.sql` with the real credentials.

3. **üêò PostgreSQL runs any init scripts found in** `/docker-entrypoint-initdb.d/`

    This happens only the first time the container is created ‚Äî if the volume is already initialized, this is skipped.

4. **üí• PostgreSQL executes** `init.sql`

    This final SQL script does the following:

    * Creates the `app_user` with a password.
    * Grants it basic privileges on the database and public schema.
    * Ensures that future tables and sequences will also be accessible to this user.

## üìÅ Files Overview

| File                | Purpose                                                                               |
| ------------------- | ------------------------------------------------------------------------------------- |
| `init.sh`           | Shell script run during container setup to process env variables into SQL             |
| `init.template.sql` | SQL template file with `${VARIABLES}` placeholders                                    |
| `init.sql`          | Final SQL generated by the script and run by Postgres                                 |
| `.env`              | Holds DB credentials like `DB_APP_USER`, `DB_APP_USER_PASSWORD`, etc. (not committed) |
| `.env.example`      | Template for .env, committed for team use                                             |

## ‚ö†Ô∏è Notes

* `init.sql` is auto-generated ‚Äî don't commit it to git. It is also ignored by Docker in [.dockerignore](.dockerignore).
* To re-run the script, you'd have to delete the volume:
    ```bash
    docker-compose down -v
    ```

## üß™ Example Use Case

Backend app (FastAPI) connects to DB using the limited `app_user`, not the 
`postgres` admin user:

```python
SQLALCHEMY_DATABASE_URL=postgresql+psycopg2://${DB_APP_USER}:${DB_APP_USER_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}
```

This ensures the app cannot drop tables or alter roles ‚Äî only perform what it's allowed to.